# MySQL实战45讲

##### 一条SQL是如何执行的？

| Q                                                 | A                                                            |
| ------------------------------------------------- | ------------------------------------------------------------ |
| 说下MySQL的架构或者是组成                         | 客户端、连接器、分析器、优化器、执行器、存储引擎             |
| 各个模块的作用是什么                              | 分析器：SQL是什么意思；优化器：怎么执行效率更高，执行器操作引擎，返回结果 |
| 如果以条SQL语句执行发生了错误，你应该关注的是什么 | 关注use near                                                 |
| 在什么阶段会判断当前用户对当前表的执行权限        | 执行阶段                                                     |
| 为什么不建议设置查询缓存                          | 因为一条更新语句就会清空当前表所有的缓存；                   |

##### 一条SQL更新语句是如何执行的？

| Q                                              | A                                                            |
| ---------------------------------------------- | ------------------------------------------------------------ |
| MySQL中的两个日志模块，分别属于哪一层          | 物理日志redo log，属于引擎层、逻辑日志bin log属于server层    |
| `write pos` 、checkpoint分别是什么，作用是什么 | write pos标记redo log写的位置，checkpoint 表示往磁盘写的位置 |
| redo log 和 bin log的三点区别                  | :one: redo log 是`InnoDB`引擎特有的，bin log所有引擎都可以只使用<br>:two: redo log 是物理日志，记录的是在某个数据页上做了什么修改<b>，bin log记录的是SQL的原始逻辑<br>:three: redo log 是循环写的，空间固定会用完，bin log是追加写的，满了会切换到下一个 |
| WAL                                            | Write-Ahead Logging，先写日志，在写磁盘，避免过多的IO操作，提高效率 |
| redo log能够实现什么？                         | crash-safe ，有了redo log Inno DB可以保证在数据库异常重启之后，之前提交的记录不会异常丢失，这个能力就是crash-safe |
| 两阶段提交的意义                               | 保证两份日志之间的逻辑一致，如此一来，恢复数据库的时候，使用不同的日志，数据库数据是一致的 |
|                                                |                                                              |

##### 事务隔离

| Q                           | A                                    |
| --------------------------- | ------------------------------------ |
| 什么是事务                  | 一次操作，要么全部成功，要么全部失败 |
| 在MySQL中，事务在哪一层实现 |                                      |
|                             |                                      |
|                             |                                      |
|                             |                                      |

**IO成本**

IO成本就是寻址时间和上线文切换所需要的时间，最主要是用户态和内核态的上下文切换。我们知道用户态是无法直接访问磁盘等硬件上的数据的，只能通过操作系统去调内核态的接口，用内核态的线程去访问。 这里的上下文切换指的是同进程的线程上下文切换，所谓上下文就是线程运行需要的环境信息。 首先，用户态线程需要一些中间计算结果保存CPU寄存器，保存CPU指令的地址到程序计数器（执行顺序保证），还要保存栈的信息等一些线程私有的信息。 然后切换到内核态的线程执行，就需要把线程的私有信息从寄存器，程序计数器里读出来，然后执行读磁盘上的数据。读完后返回，又要把线程的信息写进寄存器和程序计数器。 切换到用户态后，用户态线程又要读之前保存的线程执行的环境信息出来，恢复执行。这个过程主要是消耗时间资源。 --来自《Linux性能优化实战》。